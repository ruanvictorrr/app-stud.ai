module.exports = {

"[project]/.next-internal/server/app/api/process-study-material/route/actions.js [app-rsc] (server actions loader, ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/punycode [external] (punycode, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/node:fs [external] (node:fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}}),
"[externals]/node:stream [external] (node:stream, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}}),
"[externals]/child_process [external] (child_process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/process [external] (process, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/fs/promises [external] (fs/promises, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs/promises", () => require("fs/promises"));

module.exports = mod;
}}),
"[externals]/node:stream/promises [external] (node:stream/promises, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("node:stream/promises", () => require("node:stream/promises"));

module.exports = mod;
}}),
"[externals]/net [external] (net, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}}),
"[externals]/tls [external] (tls, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}}),
"[project]/src/lib/prisma.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "prisma": ()=>prisma
});
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
function createPrismaClient() {
    const client = new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]({
        log: ("TURBOPACK compile-time truthy", 1) ? [
            "error",
            "warn"
        ] : "TURBOPACK unreachable"
    });
    return client;
}
const prisma = globalThis.__prisma ?? createPrismaClient();
if ("TURBOPACK compile-time truthy", 1) {
    globalThis.__prisma = prisma;
}
}),
"[project]/src/lib/auth.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "clearSessionCookie": ()=>clearSessionCookie,
    "createSession": ()=>createSession,
    "destroySession": ()=>destroySession,
    "getCurrentUser": ()=>getCurrentUser,
    "hashPassword": ()=>hashPassword,
    "isAdminEmail": ()=>isAdminEmail,
    "requireUser": ()=>requireUser,
    "setSessionCookie": ()=>setSessionCookie,
    "verifyPassword": ()=>verifyPassword
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bcryptjs/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/prisma.ts [app-route] (ecmascript)");
;
;
;
;
const SESSION_COOKIE = "studai_session";
const SESSION_DAYS = 30;
function isAdminEmail(email) {
    const one = (process.env.ADMIN_EMAIL || "").trim().toLowerCase();
    if (one && email.toLowerCase() === one) return true;
    const many = (process.env.ADMIN_EMAILS || "").split(",").map((s)=>s.trim().toLowerCase()).filter(Boolean);
    if (many.length && many.includes(email.toLowerCase())) return true;
    return false;
}
async function hashPassword(password) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].hash(password, 10);
}
async function verifyPassword(password, passwordHash) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bcryptjs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].compare(password, passwordHash);
}
async function createSession(userId, days = SESSION_DAYS) {
    const sessionToken = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomBytes"])(32).toString("hex");
    const expires = new Date(Date.now() + days * 24 * 60 * 60 * 1000);
    await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].session.create({
        data: {
            userId,
            sessionToken,
            expires
        }
    });
    return {
        sessionToken,
        expires
    };
}
async function destroySession(sessionToken) {
    try {
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].session.delete({
            where: {
                sessionToken
            }
        });
    } catch  {
    // ignore
    }
}
async function setSessionCookie(params) {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    cookieStore.set(SESSION_COOKIE, params.token, {
        httpOnly: true,
        sameSite: "lax",
        secure: ("TURBOPACK compile-time value", "development") === "production",
        path: "/",
        expires: params.expires
    });
}
async function clearSessionCookie() {
    const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
    cookieStore.set(SESSION_COOKIE, "", {
        httpOnly: true,
        sameSite: "lax",
        secure: ("TURBOPACK compile-time value", "development") === "production",
        path: "/",
        expires: new Date(0)
    });
}
async function getCurrentUser() {
    try {
        const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
        const token = cookieStore.get(SESSION_COOKIE)?.value;
        if (!token) return null;
        const session = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].session.findUnique({
            where: {
                sessionToken: token
            },
            include: {
                user: true
            }
        });
        if (!session) return null;
        if (session.expires && session.expires.getTime() < Date.now()) {
            return null;
        }
        if (!session.user) return null;
        return {
            id: session.user.id,
            email: session.user.email,
            role: session.user.role,
            name: session.user.name ?? null
        };
    } catch  {
        console.warn("[auth] DB indisponível, retornando user=null");
        return null;
    }
}
async function requireUser() {
    const user = await getCurrentUser();
    if (!user) {
        const err = new Error("Não autorizado");
        err.status = 401;
        throw err;
    }
    return user;
}
}),
"[project]/src/app/api/process-study-material/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "POST": ()=>POST,
    "dynamic": ()=>dynamic,
    "runtime": ()=>runtime
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/genai/dist/node/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/auth.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$os__$5b$external$5d$__$28$os$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/os [external] (os, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs/promises [external] (fs/promises, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdf$2d$parse$2f$dist$2f$pdf$2d$parse$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/pdf-parse/dist/pdf-parse/esm/index.js [app-route] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdf$2d$parse$2f$dist$2f$pdf$2d$parse$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pdf-parse/dist/pdf-parse/esm/index.js [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const runtime = "nodejs";
const dynamic = "force-dynamic";
const FREE_MONTHLY_LIMIT = Number(process.env.FREE_MONTHLY_LIMIT || "10");
// ---------- helpers ----------
function hasValue(v) {
    return typeof v === "string" && v.trim().length > 0;
}
function sleep(ms) {
    return new Promise((r)=>setTimeout(r, ms));
}
function monthKey(d = new Date()) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    return `${y}-${m}`;
}
function isProActive(user) {
    if (user?.role === "ADMIN") return true;
    if (user?.plan === "PRO") {
        if (!user?.proUntil) return true;
        return new Date(user.proUntil).getTime() > Date.now();
    }
    return false;
}
function getGeminiKey() {
    return process.env.GEMINI_API_KEY || process.env.GOOGLE_API_KEY || "";
}
function safeParseJson(raw) {
    try {
        return JSON.parse(raw);
    } catch  {
        return null;
    }
}
function getStudySchema() {
    return {
        type: "object",
        additionalProperties: false,
        required: [
            "topic",
            "flashcards",
            "summary"
        ],
        properties: {
            topic: {
                type: "string"
            },
            flashcards: {
                type: "array",
                items: {
                    type: "object",
                    additionalProperties: false,
                    required: [
                        "id",
                        "question",
                        "answer"
                    ],
                    properties: {
                        id: {
                            type: "integer"
                        },
                        question: {
                            type: "string"
                        },
                        answer: {
                            type: "string"
                        }
                    }
                }
            },
            summary: {
                type: "object",
                additionalProperties: false,
                required: [
                    "title",
                    "style",
                    "difficulty",
                    "mainTopics",
                    "keyPoints"
                ],
                properties: {
                    title: {
                        type: "string"
                    },
                    style: {
                        type: "string"
                    },
                    difficulty: {
                        type: "string"
                    },
                    mainTopics: {
                        type: "array",
                        items: {
                            type: "object",
                            additionalProperties: false,
                            required: [
                                "id",
                                "title",
                                "content",
                                "icon"
                            ],
                            properties: {
                                id: {
                                    type: "integer"
                                },
                                title: {
                                    type: "string"
                                },
                                content: {
                                    type: "string"
                                },
                                icon: {
                                    type: "string"
                                }
                            }
                        }
                    },
                    keyPoints: {
                        type: "array",
                        items: {
                            type: "string"
                        }
                    }
                }
            }
        }
    };
}
function buildPromptFromText(params) {
    const styleText = params.summaryStyle === "bullet" ? "Resuma em formato de tópicos (bullet points), direto e objetivo." : "Resuma explicado, em texto corrido e bem didático, com exemplos quando fizer sentido.";
    const diffText = params.difficulty === "easy" ? "Flashcards fáceis (definições e perguntas diretas)." : params.difficulty === "hard" ? "Flashcards difíceis (perguntas que exigem raciocínio, aplicação e comparação)." : "Flashcards de dificuldade média (conceitos + aplicação simples).";
    const baseJson = `Retorne APENAS um JSON válido com esta estrutura:
{
  "topic": "Tópico principal do material",
  "flashcards": [
    { "id": 1, "question": "Pergunta clara e objetiva", "answer": "Resposta completa e educativa" }
  ],
  "summary": {
    "title": "Título do resumo",
    "style": "${params.summaryStyle}",
    "difficulty": "${params.difficulty}",
    "mainTopics": [
      { "id": 1, "title": "Título do tópico", "content": "Conteúdo detalhado do tópico", "icon": "emoji apropriado" }
    ],
    "keyPoints": ["ponto-chave 1", "ponto-chave 2"]
  }
}`;
    const rules = `Regras:
- Crie exatamente ${params.flashcardsCount} flashcards.
- ${diffText}
- ${styleText}
- Crie 3 a 5 tópicos principais em summary.mainTopics.
- Seja educativo e completo.
- Não inclua texto fora do JSON.`;
    const snippet = params.text.slice(0, 12000);
    return `Analise este conteúdo de estudo e crie material educacional:

${snippet}

${baseJson}

${rules}`;
}
function buildPromptForPdfOcr(params) {
    // Importante: aqui o conteúdo vem do ARQUIVO PDF anexado (via URI).
    // Então o prompt não precisa colar o texto; precisa instruir a extrair/OCR.
    const styleText = params.summaryStyle === "bullet" ? "Resuma em formato de tópicos (bullet points), direto e objetivo." : "Resuma explicado, em texto corrido e bem didático, com exemplos quando fizer sentido.";
    const diffText = params.difficulty === "easy" ? "Flashcards fáceis (definições e perguntas diretas)." : params.difficulty === "hard" ? "Flashcards difíceis (perguntas que exigem raciocínio, aplicação e comparação)." : "Flashcards de dificuldade média (conceitos + aplicação simples).";
    const baseJson = `Retorne APENAS um JSON válido com esta estrutura:
{
  "topic": "Tópico principal do material",
  "flashcards": [
    { "id": 1, "question": "Pergunta clara e objetiva", "answer": "Resposta completa e educativa" }
  ],
  "summary": {
    "title": "Título do resumo",
    "style": "${params.summaryStyle}",
    "difficulty": "${params.difficulty}",
    "mainTopics": [
      { "id": 1, "title": "Título do tópico", "content": "Conteúdo detalhado do tópico", "icon": "emoji apropriado" }
    ],
    "keyPoints": ["ponto-chave 1", "ponto-chave 2"]
  }
}`;
    const rules = `Regras:
- O conteúdo está em um ARQUIVO PDF anexado. Extraia o texto do PDF.
- Se o PDF for escaneado/imagem, faça OCR e recupere o máximo de texto possível.
- Crie exatamente ${params.flashcardsCount} flashcards.
- ${diffText}
- ${styleText}
- Crie 3 a 5 tópicos principais em summary.mainTopics.
- Seja educativo e completo.
- Não inclua texto fora do JSON.`;
    return `Você é um assistente educacional. Use o PDF anexado como fonte.

${baseJson}

${rules}`;
}
// ---------- PDF text extraction ----------
async function extractPdfText(buffer) {
    try {
        const data = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdf$2d$parse$2f$dist$2f$pdf$2d$parse$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__(buffer);
        const text = (data?.text || "").replace(/\s+\n/g, "\n").trim();
        return text;
    } catch  {
        return "";
    }
}
function looksLikeHasRealText(text) {
    // heurística simples: texto suficiente e com “densidade” mínima
    const t = (text || "").trim();
    if (t.length < 300) return false;
    // se quase tudo for caracteres estranhos, também não
    const weird = t.match(/[^\p{L}\p{N}\p{P}\p{Z}\n\r]/gu)?.length ?? 0;
    const ratio = weird / Math.max(1, t.length);
    return ratio < 0.05;
}
// ---------- quota control ----------
async function enforceAndIncrementUsage(userId) {
    const now = new Date();
    const mk = monthKey(now);
    const user = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.findUnique({
        where: {
            id: userId
        }
    });
    if (!user) throw Object.assign(new Error("Usuário não encontrado."), {
        status: 401
    });
    if (isProActive(user)) {
        return {
            ok: true,
            user,
            limited: false,
            remaining: null
        };
    }
    const last = user.monthlyResetAt ? monthKey(user.monthlyResetAt) : null;
    if (last !== mk) {
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.update({
            where: {
                id: userId
            },
            data: {
                monthlyUsed: 0,
                monthlyResetAt: now
            }
        });
        user.monthlyUsed = 0;
        user.monthlyResetAt = now;
    }
    if ((user.monthlyUsed ?? 0) >= FREE_MONTHLY_LIMIT) {
        return {
            ok: false,
            user,
            limited: true,
            remaining: 0
        };
    }
    const updated = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].user.update({
        where: {
            id: userId
        },
        data: {
            monthlyUsed: {
                increment: 1
            }
        }
    });
    const remaining = Math.max(0, FREE_MONTHLY_LIMIT - (updated.monthlyUsed ?? 0));
    return {
        ok: true,
        user: updated,
        limited: true,
        remaining
    };
}
// ---------- providers ----------
async function runWithOpenAI(params) {
    const openai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]({
        apiKey: process.env.OPENAI_API_KEY
    });
    const completion = await openai.chat.completions.create({
        model: params.model,
        messages: [
            {
                role: "system",
                content: "Você é um assistente educacional especializado em criar materiais de estudo. Responda sempre com JSON válido e nada além disso."
            },
            {
                role: "user",
                content: params.content
            }
        ],
        response_format: {
            type: "json_object"
        },
        max_tokens: 2000
    });
    const raw = completion.choices[0]?.message?.content || "";
    const parsed = safeParseJson(raw);
    if (!parsed) throw new Error("OpenAI retornou JSON inválido.");
    return parsed;
}
async function runWithGeminiText(params) {
    const ai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenAI"]({
        apiKey: getGeminiKey()
    });
    const retries = params.retries ?? 2;
    for(let attempt = 0; attempt <= retries; attempt++){
        try {
            const response = await ai.models.generateContent({
                model: params.model,
                contents: params.prompt,
                config: {
                    systemInstruction: "Você é um assistente educacional especializado em criar materiais de estudo. Responda apenas em JSON seguindo o schema.",
                    responseMimeType: "application/json",
                    responseJsonSchema: getStudySchema()
                }
            });
            const raw = response.text || "";
            const parsed = safeParseJson(raw);
            if (!parsed) throw new Error("Gemini retornou JSON inválido.");
            return parsed;
        } catch (err) {
            const status = err?.status || err?.code;
            const msg = (err?.message || "").toString();
            const overloaded = status === 503 || msg.includes("overloaded") || msg.includes("UNAVAILABLE");
            if (attempt < retries && overloaded) {
                await sleep(1000 * (attempt + 1) * (attempt + 1));
                continue;
            }
            throw err;
        }
    }
    throw new Error("Falha ao gerar com Gemini.");
}
async function uploadBufferToTmpFile(buffer, ext) {
    const name = `studai-${Date.now()}-${__TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomBytes(6).toString("hex")}${ext}`;
    const tmpPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(__TURBOPACK__imported__module__$5b$externals$5d2f$os__$5b$external$5d$__$28$os$2c$__cjs$29$__["default"].tmpdir(), name);
    await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["writeFile"])(tmpPath, buffer);
    return tmpPath;
}
async function runWithGeminiPdf(params) {
    const apiKey = getGeminiKey();
    if (!apiKey) {
        throw Object.assign(new Error("GEMINI_API_KEY não configurada (necessária para OCR em PDF escaneado)."), {
            status: 500
        });
    }
    const ai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenAI"]({
        apiKey
    });
    const retries = params.retries ?? 1;
    for(let attempt = 0; attempt <= retries; attempt++){
        let tmpPath = null;
        try {
            tmpPath = await uploadBufferToTmpFile(params.pdfBuffer, ".pdf");
            // Upload de PDF (suporta PDF e OCR quando necessário) :contentReference[oaicite:1]{index=1}
            const myfile = await ai.files.upload({
                file: tmpPath,
                config: {
                    mimeType: "application/pdf"
                }
            });
            const response = await ai.models.generateContent({
                model: params.model,
                contents: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createUserContent"])([
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createPartFromUri"])(myfile.uri, myfile.mimeType),
                    "\n\n",
                    params.prompt
                ]),
                config: {
                    systemInstruction: "Você é um assistente educacional especializado em criar materiais de estudo. Responda apenas em JSON seguindo o schema.",
                    responseMimeType: "application/json",
                    responseJsonSchema: getStudySchema()
                }
            });
            const raw = response.text || "";
            const parsed = safeParseJson(raw);
            if (!parsed) throw new Error("Gemini retornou JSON inválido.");
            return parsed;
        } catch (err) {
            const status = err?.status || err?.code;
            const msg = (err?.message || "").toString();
            const overloaded = status === 503 || msg.includes("overloaded") || msg.includes("UNAVAILABLE");
            if (attempt < retries && overloaded) {
                await sleep(1000 * (attempt + 1) * (attempt + 1));
                continue;
            }
            throw err;
        } finally{
            if (tmpPath) {
                await (0, __TURBOPACK__imported__module__$5b$externals$5d2f$fs$2f$promises__$5b$external$5d$__$28$fs$2f$promises$2c$__cjs$29$__["unlink"])(tmpPath).catch(()=>{});
            }
        }
    }
    throw new Error("Falha ao gerar com Gemini a partir do PDF.");
}
function isRetryableAIError(err) {
    const status = err?.status || err?.code;
    const msg = (err?.message || "").toString();
    if (status === 429) return true; // rate/quota
    if (status === 503) return true; // overloaded
    if (msg.includes("overloaded") || msg.includes("UNAVAILABLE")) return true;
    if (msg.includes("insufficient_quota")) return true;
    if (msg.includes("quota")) return true;
    if (msg.includes("rate")) return true;
    return false;
}
function pickProviderOrder() {
    const forced = (process.env.AI_PROVIDER || "auto").toLowerCase();
    const hasOpenAI = hasValue(process.env.OPENAI_API_KEY);
    const hasGemini = hasValue(process.env.GEMINI_API_KEY) || hasValue(process.env.GOOGLE_API_KEY);
    if (forced === "gemini") {
        if (!hasGemini) throw Object.assign(new Error("GEMINI_API_KEY não configurada."), {
            status: 500
        });
        return hasOpenAI ? [
            "gemini",
            "openai"
        ] : [
            "gemini"
        ];
    }
    if (forced === "openai") {
        if (!hasOpenAI) throw Object.assign(new Error("OPENAI_API_KEY não configurada."), {
            status: 500
        });
        return hasGemini ? [
            "openai",
            "gemini"
        ] : [
            "openai"
        ];
    }
    // auto: Gemini primeiro (evita 429 OpenAI)
    if (hasGemini && hasOpenAI) return [
        "gemini",
        "openai"
    ];
    if (hasGemini) return [
        "gemini"
    ];
    if (hasOpenAI) return [
        "openai"
    ];
    throw Object.assign(new Error("Nenhuma chave de IA encontrada."), {
        status: 500
    });
}
async function POST(request) {
    try {
        const current = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["requireUser"])();
        const quota = await enforceAndIncrementUsage(current.id);
        if (!quota.ok) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Limite do plano grátis atingido.",
                code: "FREE_LIMIT_REACHED",
                limit: FREE_MONTHLY_LIMIT,
                remaining: 0
            }, {
                status: 402
            });
        }
        const formData = await request.formData();
        const file = formData.get("file");
        const flashcardsCount = Math.min(50, Math.max(1, Number(formData.get("flashcardsCount") || 10)));
        const summaryStyle = formData.get("summaryStyle") || "bullet";
        const difficulty = formData.get("difficulty") || "medium";
        if (!file) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Nenhum arquivo foi enviado"
            }, {
                status: 400
            });
        }
        const bytes = await file.arrayBuffer();
        const buffer = Buffer.from(bytes);
        const mimeType = file.type || "application/octet-stream";
        const isPdf = mimeType === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
        const isImage = mimeType.startsWith("image/");
        // evita uploads gigantes (especialmente PDF escaneado)
        const MAX_BYTES = 20 * 1024 * 1024; // 20MB
        if (buffer.length > MAX_BYTES) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Arquivo muito grande (máx. 20MB)."
            }, {
                status: 413
            });
        }
        const openaiModel = process.env.OPENAI_MODEL || "gpt-4o-mini";
        const geminiModel = process.env.GEMINI_MODEL || "gemini-2.0-flash";
        const order = pickProviderOrder();
        let parsedResult = null;
        let used = null;
        let lastErr = null;
        // ---------- PDF path ----------
        if (isPdf) {
            // 1) tenta extrair texto real
            const extracted = await extractPdfText(buffer);
            if (looksLikeHasRealText(extracted)) {
                // PDF com texto: manda o texto pro modelo (sem binário!)
                const prompt = buildPromptFromText({
                    text: extracted,
                    flashcardsCount,
                    summaryStyle,
                    difficulty
                });
                for (const provider of order){
                    try {
                        if (provider === "gemini") {
                            parsedResult = await runWithGeminiText({
                                prompt,
                                model: geminiModel,
                                retries: 2
                            });
                            used = "gemini";
                        } else {
                            parsedResult = await runWithOpenAI({
                                content: [
                                    {
                                        type: "text",
                                        text: prompt
                                    }
                                ],
                                model: openaiModel
                            });
                            used = "openai";
                        }
                        break;
                    } catch (err) {
                        lastErr = err;
                        if (isRetryableAIError(err)) continue;
                        throw err;
                    }
                }
            } else {
                // 2) PDF sem texto (escaneado): OCR via Gemini (upload do PDF)
                const prompt = buildPromptForPdfOcr({
                    flashcardsCount,
                    summaryStyle,
                    difficulty
                });
                try {
                    parsedResult = await runWithGeminiPdf({
                        pdfBuffer: buffer,
                        prompt,
                        model: geminiModel,
                        retries: 1
                    });
                    used = "gemini";
                } catch (err) {
                    lastErr = err;
                    const msg = (err?.message || "").toString();
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        success: false,
                        error: "Não foi possível ler este PDF (possivelmente escaneado) agora. Verifique GEMINI_API_KEY e tente novamente.",
                        details: msg,
                        code: "PDF_OCR_FAILED"
                    }, {
                        status: 503
                    });
                }
            }
        }
        // ---------- IMAGE path ----------
        if (!parsedResult && isImage) {
            const base64 = buffer.toString("base64");
            // (para imagem, Gemini geralmente é melhor/mais barato no seu caso)
            const prompt = buildPromptForPdfOcr({
                flashcardsCount,
                summaryStyle,
                difficulty
            }).replace("Use o PDF anexado como fonte.", "Use a IMAGEM anexada como fonte.");
            for (const provider of order){
                try {
                    if (provider === "gemini") {
                        const ai = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$genai$2f$dist$2f$node$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenAI"]({
                            apiKey: getGeminiKey()
                        });
                        const response = await ai.models.generateContent({
                            model: geminiModel,
                            contents: [
                                {
                                    inlineData: {
                                        mimeType,
                                        data: base64
                                    }
                                },
                                {
                                    text: prompt
                                }
                            ],
                            config: {
                                systemInstruction: "Você é um assistente educacional especializado em criar materiais de estudo. Responda apenas em JSON seguindo o schema.",
                                responseMimeType: "application/json",
                                responseJsonSchema: getStudySchema()
                            }
                        });
                        const raw = response.text || "";
                        const parsed = safeParseJson(raw);
                        if (!parsed) throw new Error("Gemini retornou JSON inválido.");
                        parsedResult = parsed;
                        used = "gemini";
                    } else {
                        const content = [
                            {
                                type: "text",
                                text: prompt
                            },
                            {
                                type: "image_url",
                                image_url: {
                                    url: `data:${mimeType};base64,${base64}`
                                }
                            }
                        ];
                        parsedResult = await runWithOpenAI({
                            content,
                            model: openaiModel
                        });
                        used = "openai";
                    }
                    break;
                } catch (err) {
                    lastErr = err;
                    if (isRetryableAIError(err)) continue;
                    throw err;
                }
            }
        }
        // ---------- TEXT (non-pdf, non-image) path ----------
        if (!parsedResult && !isImage && !isPdf) {
            // aqui só vale se for um arquivo textual (txt/md/etc).
            // NÃO converta binário pra utf-8.
            const text = buffer.toString("utf-8").trim();
            if (!text || text.length < 50) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    success: false,
                    error: "Não foi possível extrair texto deste arquivo. Envie um PDF, imagem, ou texto (txt/md)."
                }, {
                    status: 400
                });
            }
            const prompt = buildPromptFromText({
                text,
                flashcardsCount,
                summaryStyle,
                difficulty
            });
            for (const provider of order){
                try {
                    if (provider === "gemini") {
                        parsedResult = await runWithGeminiText({
                            prompt,
                            model: geminiModel,
                            retries: 2
                        });
                        used = "gemini";
                    } else {
                        parsedResult = await runWithOpenAI({
                            content: [
                                {
                                    type: "text",
                                    text: prompt
                                }
                            ],
                            model: openaiModel
                        });
                        used = "openai";
                    }
                    break;
                } catch (err) {
                    lastErr = err;
                    if (isRetryableAIError(err)) continue;
                    throw err;
                }
            }
        }
        // ---------- post-check ----------
        if (!parsedResult) {
            const msg = (lastErr?.message || "").toString();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Falha ao gerar com IA.",
                details: msg
            }, {
                status: 503
            });
        }
        if (!parsedResult?.topic || !parsedResult?.flashcards || !parsedResult?.summary) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Resposta inválida do modelo (faltou topic/flashcards/summary).",
                code: "INVALID_AI_RESPONSE",
                raw: parsedResult
            }, {
                status: 502
            });
        }
        await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].studyMaterial.create({
            data: {
                userId: current.id,
                topic: String(parsedResult.topic || "Material"),
                originalFilename: file.name,
                mimeType,
                data: parsedResult
            }
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            provider: used,
            remaining: quota.limited && typeof quota.remaining === "number" ? quota.remaining : null,
            data: parsedResult
        });
    } catch (error) {
        const status = error?.status || 500;
        const msg = (error?.message || "").toString();
        if (status === 401) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Não autorizado."
            }, {
                status: 401
            });
        }
        console.error("Erro ao processar arquivo:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: "Erro ao processar o arquivo",
            details: msg
        }, {
            status: status >= 400 && status <= 599 ? status : 500
        });
    }
}
}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__06f8ea5d._.js.map